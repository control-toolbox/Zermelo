!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfun_d in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: hd
!   with respect to varying inputs: p x
!   RW status of diff variables: p:in x:in hd:out
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r4996) - 25 Oct 2013 15:08
!
!  Differentiation of hfun in forward (tangent) mode (with options fixinterface):
!   variations   of useful results: h
!   with respect to varying inputs: p x
!   RW status of diff variables: h:out p:in x:in
! Lindblad
SUBROUTINE HFUN_D_D(x, xd0, xd, p, pd0, pd, d, h, hd, hdd)
  IMPLICIT NONE
  DOUBLE PRECISION, INTENT(IN) :: x(2), p(2), d
  DOUBLE PRECISION, INTENT(IN) :: xd0(2), pd0(2)
  DOUBLE PRECISION, INTENT(IN) :: xd(2), pd(2)
  DOUBLE PRECISION, INTENT(OUT) :: h
  DOUBLE PRECISION, INTENT(OUT) :: hd
  DOUBLE PRECISION, INTENT(OUT) :: hdd
! local variables
  DOUBLE PRECISION :: r, th, pr, pth
  DOUBLE PRECISION :: rd0, prd0, pthd0
  DOUBLE PRECISION :: rd, prd, pthd
  DOUBLE PRECISION :: l, m2, mu
  DOUBLE PRECISION :: m2d0, mud0
  DOUBLE PRECISION :: m2d, mud
  DOUBLE PRECISION :: m2dd, mudd
  INTRINSIC SIN
  INTRINSIC SQRT
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d0
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: arg1dd
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result1d
  DOUBLE PRECISION :: result1dd
  INTRINSIC COS
  DOUBLE PRECISION :: result10
  DOUBLE PRECISION :: result10d
  rd = xd(1)
  rd0 = xd0(1)
  r = x(1)
  th = x(2)
  prd = pd(1)
  prd0 = pd0(1)
  pr = p(1)
  pthd = pd(2)
  pthd0 = pd0(2)
  pth = p(2)
  l = 4d0/5d0
  m2dd = ((2*rd*((rd0*COS(r)**2-SIN(r)**2*rd0)*(1d0-l*SIN(r)**2)-SIN(r)&
&   **2*COS(r)**2*l*2*rd0)+l*2*rd*(3*SIN(r)**2*rd0*COS(r)**2-SIN(r)**4*&
&   rd0))*(1d0-l*SIN(r)**2)**2+(2*SIN(r)*rd*COS(r)*(1d0-l*SIN(r)**2)+SIN&
&   (r)**3*l*2*rd*COS(r))*2**2*(1d0-l*SIN(r)**2)*l*SIN(r)*rd0*COS(r))/((&
&   1d0-l*SIN(r)**2)**2)**2
  m2d = (2*SIN(r)*rd*COS(r)*(1d0-l*SIN(r)**2)+SIN(r)**3*l*2*rd*COS(r))/(&
&   1d0-l*SIN(r)**2)**2
  m2d0 = (2*SIN(r)*rd0*COS(r)*(1d0-l*SIN(r)**2)+SIN(r)**3*l*2*rd0*COS(r)&
&   )/(1d0-l*SIN(r)**2)**2
  m2 = SIN(r)**2/(1d0-l*SIN(r)**2)
  mudd = -(d*2**2*rd*rd0*SIN(2*r))
  mud = d*2*rd*COS(2*r)
  mud0 = d*2*rd0*COS(2*r)
  mu = d*SIN(2*r)
  arg1dd = 2*prd*prd0 + ((2*pthd*(pthd0*m2+pth*m2d0)-2*pth*pthd0*m2d-pth&
&   **2*m2dd)*m2**2-(2*pth*pthd*m2-pth**2*m2d)*2*m2*m2d0)/(m2**2)**2
  arg1d = 2*pr*prd + (2*pth*pthd*m2-pth**2*m2d)/m2**2
  arg1d0 = 2*pr*prd0 + (2*pth*pthd0*m2-pth**2*m2d0)/m2**2
  arg1 = pr**2 + pth**2/m2
  IF (arg1 .EQ. 0.0) THEN
    result1d = 0.d0
    result1dd = 0.D0
  ELSE
    IF (arg1 .EQ. 0.0) THEN
      result10d = 0.D0
    ELSE
      result10d = arg1d0/(2.0*SQRT(arg1))
    END IF
    result10 = SQRT(arg1)
    result1dd = (arg1dd*2.0*result10-arg1d*2.0*result10d)/(2.0*result10)&
&     **2
    result1d = arg1d/(2.0*result10)
  END IF
  result1 = SQRT(arg1)
  hdd = mudd*pr + mud*prd0 + prd*mud0 + result1dd
  hd = mud*pr + mu*prd + result1d
  h = mu*pr + result1
END SUBROUTINE HFUN_D_D

